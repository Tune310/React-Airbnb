{"ast":null,"code":"/**\n * @fileoverview\n * @suppress {checkPrototypalTypes}\n * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\nimport { PropertyAccessors } from './property-accessors.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nconst HOST_DIR = /:host\\(:dir\\((ltr|rtl)\\)\\)/g;\nconst HOST_DIR_REPLACMENT = ':host([dir=\"$1\"])';\nconst EL_DIR = /([\\s\\w-#\\.\\[\\]\\*]*):dir\\((ltr|rtl)\\)/g;\nconst EL_DIR_REPLACMENT = ':host([dir=\"$2\"]) $1';\nconst DIR_CHECK = /:dir\\((?:ltr|rtl)\\)/;\nconst SHIM_SHADOW = Boolean(window['ShadyDOM'] && window['ShadyDOM']['inUse']);\n/**\n * @type {!Array<!Polymer_DirMixin>}\n */\n\nconst DIR_INSTANCES = [];\n/** @type {?MutationObserver} */\n\nlet observer = null;\nlet DOCUMENT_DIR = '';\n\nfunction getRTL() {\n  DOCUMENT_DIR = document.documentElement.getAttribute('dir');\n}\n/**\n * @param {!Polymer_DirMixin} instance Instance to set RTL status on\n */\n\n\nfunction setRTL(instance) {\n  if (!instance.__autoDirOptOut) {\n    const el =\n    /** @type {!HTMLElement} */\n    instance;\n    el.setAttribute('dir', DOCUMENT_DIR);\n  }\n}\n\nfunction updateDirection() {\n  getRTL();\n  DOCUMENT_DIR = document.documentElement.getAttribute('dir');\n\n  for (let i = 0; i < DIR_INSTANCES.length; i++) {\n    setRTL(DIR_INSTANCES[i]);\n  }\n}\n\nfunction takeRecords() {\n  if (observer && observer.takeRecords().length) {\n    updateDirection();\n  }\n}\n/**\n * Element class mixin that allows elements to use the `:dir` CSS Selector to\n * have text direction specific styling.\n *\n * With this mixin, any stylesheet provided in the template will transform\n * `:dir` into `:host([dir])` and sync direction with the page via the\n * element's `dir` attribute.\n *\n * Elements can opt out of the global page text direction by setting the `dir`\n * attribute directly in `ready()` or in HTML.\n *\n * Caveats:\n * - Applications must set `<html dir=\"ltr\">` or `<html dir=\"rtl\">` to sync\n *   direction\n * - Automatic left-to-right or right-to-left styling is sync'd with the\n *   `<html>` element only.\n * - Changing `dir` at runtime is supported.\n * - Opting out of the global direction styling is permanent\n *\n * @mixinFunction\n * @polymer\n * @appliesMixin PropertyAccessors\n * @template T\n * @param {function(new:T)} superClass Class to apply mixin to.\n * @return {function(new:T)} superClass with mixin applied.\n */\n\n\nexport const DirMixin = dedupingMixin(base => {\n  if (!SHIM_SHADOW) {\n    if (!observer) {\n      getRTL();\n      observer = new MutationObserver(updateDirection);\n      observer.observe(document.documentElement, {\n        attributes: true,\n        attributeFilter: ['dir']\n      });\n    }\n  }\n  /**\n   * @constructor\n   * @implements {Polymer_PropertyAccessors}\n   * @private\n   */\n\n\n  const elementBase = PropertyAccessors(base);\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_DirMixin}\n   */\n\n  class Dir extends elementBase {\n    /**\n     * @param {string} cssText .\n     * @param {string} baseURI .\n     * @return {string} .\n     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do\n     * @nocollapse\n     */\n    static _processStyleText(cssText, baseURI) {\n      // TODO(https://github.com/google/closure-compiler/issues/3240):\n      //     Change back to just super.methodCall()\n      cssText = elementBase._processStyleText.call(this, cssText, baseURI);\n\n      if (!SHIM_SHADOW && DIR_CHECK.test(cssText)) {\n        cssText = this._replaceDirInCssText(cssText);\n        this.__activateDir = true;\n      }\n\n      return cssText;\n    }\n    /**\n     * Replace `:dir` in the given CSS text\n     *\n     * @param {string} text CSS text to replace DIR\n     * @return {string} Modified CSS\n     * @nocollapse\n     */\n\n\n    static _replaceDirInCssText(text) {\n      let replacedText = text;\n      replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);\n      replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);\n      return replacedText;\n    }\n\n    constructor() {\n      super();\n      /** @type {boolean} */\n\n      this.__autoDirOptOut = false;\n    }\n    /**\n     * @override\n     * @suppress {invalidCasts} Closure doesn't understand that `this` is an\n     *     HTMLElement\n     * @return {void}\n     */\n\n\n    ready() {\n      super.ready();\n      this.__autoDirOptOut =\n      /** @type {!HTMLElement} */\n      this.hasAttribute('dir');\n    }\n    /**\n     * @override\n     * @suppress {missingProperties} If it exists on elementBase, it can be\n     *   super'd\n     * @return {void}\n     */\n\n\n    connectedCallback() {\n      if (elementBase.prototype.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      if (this.constructor.__activateDir) {\n        takeRecords();\n        DIR_INSTANCES.push(this);\n        setRTL(this);\n      }\n    }\n    /**\n     * @override\n     * @suppress {missingProperties} If it exists on elementBase, it can be\n     *   super'd\n     * @return {void}\n     */\n\n\n    disconnectedCallback() {\n      if (elementBase.prototype.disconnectedCallback) {\n        super.disconnectedCallback();\n      }\n\n      if (this.constructor.__activateDir) {\n        const idx = DIR_INSTANCES.indexOf(this);\n\n        if (idx > -1) {\n          DIR_INSTANCES.splice(idx, 1);\n        }\n      }\n    }\n\n  }\n\n  Dir.__activateDir = false;\n  return Dir;\n});","map":null,"metadata":{},"sourceType":"module"}