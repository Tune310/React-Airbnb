{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Module for preparing and stamping instances of templates that utilize\n * Polymer's data-binding and declarative event listener features.\n *\n * Example:\n *\n *     // Get a template from somewhere, e.g. light DOM\n *     let template = this.querySelector('template');\n *     // Prepare the template\n *     let TemplateClass = Templatize.templatize(template);\n *     // Instance the template with an initial data model\n *     let instance = new TemplateClass({myProp: 'initial'});\n *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM\n *     this.shadowRoot.appendChild(instance.root);\n *     // Changing a property on the instance will propagate to bindings\n *     // in the template\n *     instance.myProp = 'new value';\n *\n * The `options` dictionary passed to `templatize` allows for customizing\n * features of the generated template class, including how outer-scope host\n * properties should be forwarded into template instances, how any instance\n * properties added into the template's scope should be notified out to\n * the host, and whether the instance should be decorated as a \"parent model\"\n * of any event handlers.\n *\n *     // Customize property forwarding and event model decoration\n *     let TemplateClass = Templatize.templatize(template, this, {\n *       parentModel: true,\n *       forwardHostProp(property, value) {...},\n *       instanceProps: {...},\n *       notifyInstanceProp(instance, property, value) {...},\n *     });\n *\n * @summary Module for preparing and stamping instances of templates\n *   utilizing Polymer templating features.\n */\nimport './boot.js';\nimport { PropertyEffects } from '../mixins/property-effects.js';\nimport { MutableData } from '../mixins/mutable-data.js';\nimport { strictTemplatePolicy } from './settings.js';\nimport { wrap } from './wrap.js'; // Base class for HTMLTemplateElement extension that has property effects\n// machinery for propagating host properties to children. This is an ES5\n// class only because Babel (incorrectly) requires super() in the class\n// constructor even though no `this` is used and it returns an instance.\n\nlet newInstance = null;\n/**\n * @constructor\n * @extends {HTMLTemplateElement}\n * @private\n */\n\nfunction HTMLTemplateElementExtension() {\n  return newInstance;\n}\n\nHTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {\n  constructor: {\n    value: HTMLTemplateElementExtension,\n    writable: true\n  }\n});\n/**\n * @constructor\n * @implements {Polymer_PropertyEffects}\n * @extends {HTMLTemplateElementExtension}\n * @private\n */\n\nconst DataTemplate = PropertyEffects(HTMLTemplateElementExtension);\n/**\n * @constructor\n * @implements {Polymer_MutableData}\n * @extends {DataTemplate}\n * @private\n */\n\nconst MutableDataTemplate = MutableData(DataTemplate); // Applies a DataTemplate subclass to a <template> instance\n\nfunction upgradeTemplate(template, constructor) {\n  newInstance = template;\n  Object.setPrototypeOf(template, constructor.prototype);\n  new constructor();\n  newInstance = null;\n}\n/**\n * Base class for TemplateInstance.\n * @constructor\n * @extends {HTMLElement}\n * @implements {Polymer_PropertyEffects}\n * @private\n */\n\n\nconst templateInstanceBase = PropertyEffects( // This cast shouldn't be neccessary, but Closure doesn't understand that\n// \"class {}\" is a constructor function.\n\n/** @type {function(new:Object)} */\nclass {});\n/**\n * @polymer\n * @customElement\n * @appliesMixin PropertyEffects\n * @unrestricted\n */\n\nclass TemplateInstanceBase extends templateInstanceBase {\n  constructor(props) {\n    super();\n\n    this._configureProperties(props);\n    /** @type {!StampedTemplate} */\n\n\n    this.root = this._stampTemplate(this.__dataHost); // Save list of stamped children\n\n    let children = [];\n    /** @suppress {invalidCasts} */\n\n    this.children =\n    /** @type {!NodeList} */\n    children; // Polymer 1.x did not use `Polymer.dom` here so not bothering.\n\n    for (let n = this.root.firstChild; n; n = n.nextSibling) {\n      children.push(n);\n      n.__templatizeInstance = this;\n    }\n\n    if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) {\n      this._showHideChildren(true);\n    } // Flush props only when props are passed if instance props exist\n    // or when there isn't instance props.\n\n\n    let options = this.__templatizeOptions;\n\n    if (props && options.instanceProps || !options.instanceProps) {\n      this._enableProperties();\n    }\n  }\n  /**\n   * Configure the given `props` by calling `_setPendingProperty`. Also\n   * sets any properties stored in `__hostProps`.\n   * @private\n   * @param {Object} props Object of property name-value pairs to set.\n   * @return {void}\n   */\n\n\n  _configureProperties(props) {\n    let options = this.__templatizeOptions;\n\n    if (options.forwardHostProp) {\n      for (let hprop in this.__hostProps) {\n        this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);\n      }\n    } // Any instance props passed in the constructor will overwrite host props;\n    // normally this would be a user error but we don't specifically filter them\n\n\n    for (let iprop in props) {\n      this._setPendingProperty(iprop, props[iprop]);\n    }\n  }\n  /**\n   * Forwards a host property to this instance.  This method should be\n   * called on instances from the `options.forwardHostProp` callback\n   * to propagate changes of host properties to each instance.\n   *\n   * Note this method enqueues the change, which are flushed as a batch.\n   *\n   * @param {string} prop Property or path name\n   * @param {*} value Value of the property to forward\n   * @return {void}\n   */\n\n\n  forwardHostProp(prop, value) {\n    if (this._setPendingPropertyOrPath(prop, value, false, true)) {\n      this.__dataHost._enqueueClient(this);\n    }\n  }\n  /**\n   * Override point for adding custom or simulated event handling.\n   *\n   * @override\n   * @param {!Node} node Node to add event listener to\n   * @param {string} eventName Name of event\n   * @param {function(!Event):void} handler Listener function to add\n   * @return {void}\n   */\n\n\n  _addEventListenerToNode(node, eventName, handler) {\n    if (this._methodHost && this.__templatizeOptions.parentModel) {\n      // If this instance should be considered a parent model, decorate\n      // events this template instance as `model`\n      this._methodHost._addEventListenerToNode(node, eventName, e => {\n        e.model = this;\n        handler(e);\n      });\n    } else {\n      // Otherwise delegate to the template's host (which could be)\n      // another template instance\n      let templateHost = this.__dataHost.__dataHost;\n\n      if (templateHost) {\n        templateHost._addEventListenerToNode(node, eventName, handler);\n      }\n    }\n  }\n  /**\n   * Shows or hides the template instance top level child elements. For\n   * text nodes, `textContent` is removed while \"hidden\" and replaced when\n   * \"shown.\"\n   * @param {boolean} hide Set to true to hide the children;\n   * set to false to show them.\n   * @return {void}\n   * @protected\n   */\n\n\n  _showHideChildren(hide) {\n    let c = this.children;\n\n    for (let i = 0; i < c.length; i++) {\n      let n = c[i]; // Ignore non-changes\n\n      if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {\n        if (n.nodeType === Node.TEXT_NODE) {\n          if (hide) {\n            n.__polymerTextContent__ = n.textContent;\n            n.textContent = '';\n          } else {\n            n.textContent = n.__polymerTextContent__;\n          } // remove and replace slot\n\n        } else if (n.localName === 'slot') {\n          if (hide) {\n            n.__polymerReplaced__ = document.createComment('hidden-slot');\n            wrap(wrap(n).parentNode).replaceChild(n.__polymerReplaced__, n);\n          } else {\n            const replace = n.__polymerReplaced__;\n\n            if (replace) {\n              wrap(wrap(replace).parentNode).replaceChild(n, replace);\n            }\n          }\n        } else if (n.style) {\n          if (hide) {\n            n.__polymerDisplay__ = n.style.display;\n            n.style.display = 'none';\n          } else {\n            n.style.display = n.__polymerDisplay__;\n          }\n        }\n      }\n\n      n.__hideTemplateChildren__ = hide;\n\n      if (n._showHideChildren) {\n        n._showHideChildren(hide);\n      }\n    }\n  }\n  /**\n   * Overrides default property-effects implementation to intercept\n   * textContent bindings while children are \"hidden\" and cache in\n   * private storage for later retrieval.\n   *\n   * @override\n   * @param {!Node} node The node to set a property on\n   * @param {string} prop The property to set\n   * @param {*} value The value to set\n   * @return {void}\n   * @protected\n   */\n\n\n  _setUnmanagedPropertyToNode(node, prop, value) {\n    if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {\n      node.__polymerTextContent__ = value;\n    } else {\n      super._setUnmanagedPropertyToNode(node, prop, value);\n    }\n  }\n  /**\n   * Find the parent model of this template instance.  The parent model\n   * is either another templatize instance that had option `parentModel: true`,\n   * or else the host element.\n   *\n   * @return {!Polymer_PropertyEffects} The parent model of this instance\n   */\n\n\n  get parentModel() {\n    let model = this.__parentModel;\n\n    if (!model) {\n      let options;\n      model = this;\n\n      do {\n        // A template instance's `__dataHost` is a <template>\n        // `model.__dataHost.__dataHost` is the template's host\n        model = model.__dataHost.__dataHost;\n      } while ((options = model.__templatizeOptions) && !options.parentModel);\n\n      this.__parentModel = model;\n    }\n\n    return model;\n  }\n  /**\n   * Stub of HTMLElement's `dispatchEvent`, so that effects that may\n   * dispatch events safely no-op.\n   *\n   * @param {Event} event Event to dispatch\n   * @return {boolean} Always true.\n   * @override\n   */\n\n\n  dispatchEvent(event) {\n    // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n}\n/** @type {!DataTemplate} */\n\n\nTemplateInstanceBase.prototype.__dataHost;\n/** @type {!TemplatizeOptions} */\n\nTemplateInstanceBase.prototype.__templatizeOptions;\n/** @type {!Polymer_PropertyEffects} */\n\nTemplateInstanceBase.prototype._methodHost;\n/** @type {!Object} */\n\nTemplateInstanceBase.prototype.__templatizeOwner;\n/** @type {!Object} */\n\nTemplateInstanceBase.prototype.__hostProps;\n/**\n * @constructor\n * @extends {TemplateInstanceBase}\n * @implements {Polymer_MutableData}\n * @private\n */\n\nconst MutableTemplateInstanceBase = MutableData( // This cast shouldn't be necessary, but Closure doesn't seem to understand\n// this constructor.\n\n/** @type {function(new:TemplateInstanceBase)} */\nTemplateInstanceBase);\n\nfunction findMethodHost(template) {\n  // Technically this should be the owner of the outermost template.\n  // In shadow dom, this is always getRootNode().host, but we can\n  // approximate this via cooperation with our dataHost always setting\n  // `_methodHost` as long as there were bindings (or id's) on this\n  // instance causing it to get a dataHost.\n  let templateHost = template.__dataHost;\n  return templateHost && templateHost._methodHost || templateHost;\n}\n/* eslint-disable valid-jsdoc */\n\n/**\n * @suppress {missingProperties} class.prototype is not defined for some reason\n */\n\n\nfunction createTemplatizerClass(template, templateInfo, options) {\n  /**\n   * @constructor\n   * @extends {TemplateInstanceBase}\n   */\n  let templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase; // Affordance for global mixins onto TemplatizeInstance\n\n  if (templatize.mixin) {\n    templatizerBase = templatize.mixin(templatizerBase);\n  }\n  /**\n   * Anonymous class created by the templatize\n   * @constructor\n   * @private\n   */\n\n\n  let klass = class extends templatizerBase {};\n  /** @override */\n\n  klass.prototype.__templatizeOptions = options;\n\n  klass.prototype._bindTemplate(template);\n\n  addNotifyEffects(klass, template, templateInfo, options);\n  return klass;\n}\n/**\n * Adds propagate effects from the template to the template instance for\n * properties that the host binds to the template using the `_host_` prefix.\n * \n * @suppress {missingProperties} class.prototype is not defined for some reason\n */\n\n\nfunction addPropagateEffects(template, templateInfo, options) {\n  let userForwardHostProp = options.forwardHostProp;\n\n  if (userForwardHostProp && templateInfo.hasHostProps) {\n    // Provide data API and property effects on memoized template class\n    let klass = templateInfo.templatizeTemplateClass;\n\n    if (!klass) {\n      /**\n       * @constructor\n       * @extends {DataTemplate}\n       */\n      let templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate;\n      /** @private */\n\n      klass = templateInfo.templatizeTemplateClass = class TemplatizedTemplate extends templatizedBase {}; // Add template - >instances effects\n      // and host <- template effects\n\n      let hostProps = templateInfo.hostProps;\n\n      for (let prop in hostProps) {\n        klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, {\n          fn: createForwardHostPropEffect(prop, userForwardHostProp)\n        });\n\n        klass.prototype._createNotifyingProperty('_host_' + prop);\n      }\n    }\n\n    upgradeTemplate(template, klass); // Mix any pre-bound data into __data; no need to flush this to\n    // instances since they pull from the template at instance-time\n\n    if (template.__dataProto) {\n      // Note, generally `__dataProto` could be chained, but it's guaranteed\n      // to not be since this is a vanilla template we just added effects to\n      Object.assign(template.__data, template.__dataProto);\n    } // Clear any pending data for performance\n\n\n    template.__dataTemp = {};\n    template.__dataPending = null;\n    template.__dataOld = null;\n\n    template._enableProperties();\n  }\n}\n/* eslint-enable valid-jsdoc */\n\n\nfunction createForwardHostPropEffect(hostProp, userForwardHostProp) {\n  return function forwardHostProp(template, prop, props) {\n    userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);\n  };\n}\n\nfunction addNotifyEffects(klass, template, templateInfo, options) {\n  let hostProps = templateInfo.hostProps || {};\n\n  for (let iprop in options.instanceProps) {\n    delete hostProps[iprop];\n    let userNotifyInstanceProp = options.notifyInstanceProp;\n\n    if (userNotifyInstanceProp) {\n      klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {\n        fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)\n      });\n    }\n  }\n\n  if (options.forwardHostProp && template.__dataHost) {\n    for (let hprop in hostProps) {\n      // As we're iterating hostProps in this function, note whether\n      // there were any, for an optimization in addPropagateEffects\n      if (!templateInfo.hasHostProps) {\n        templateInfo.hasHostProps = true;\n      }\n\n      klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {\n        fn: createNotifyHostPropEffect()\n      });\n    }\n  }\n}\n\nfunction createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {\n  return function notifyInstanceProp(inst, prop, props) {\n    userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);\n  };\n}\n\nfunction createNotifyHostPropEffect() {\n  return function notifyHostProp(inst, prop, props) {\n    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);\n  };\n}\n/**\n * Returns an anonymous `PropertyEffects` class bound to the\n * `<template>` provided.  Instancing the class will result in the\n * template being stamped into a document fragment stored as the instance's\n * `root` property, after which it can be appended to the DOM.\n *\n * Templates may utilize all Polymer data-binding features as well as\n * declarative event listeners.  Event listeners and inline computing\n * functions in the template will be called on the host of the template.\n *\n * The constructor returned takes a single argument dictionary of initial\n * property values to propagate into template bindings.  Additionally\n * host properties can be forwarded in, and instance properties can be\n * notified out by providing optional callbacks in the `options` dictionary.\n *\n * Valid configuration in `options` are as follows:\n *\n * - `forwardHostProp(property, value)`: Called when a property referenced\n *   in the template changed on the template's host. As this library does\n *   not retain references to templates instanced by the user, it is the\n *   templatize owner's responsibility to forward host property changes into\n *   user-stamped instances.  The `instance.forwardHostProp(property, value)`\n *    method on the generated class should be called to forward host\n *   properties into the template to prevent unnecessary property-changed\n *   notifications. Any properties referenced in the template that are not\n *   defined in `instanceProps` will be notified up to the template's host\n *   automatically.\n * - `instanceProps`: Dictionary of property names that will be added\n *   to the instance by the templatize owner.  These properties shadow any\n *   host properties, and changes within the template to these properties\n *   will result in `notifyInstanceProp` being called.\n * - `mutableData`: When `true`, the generated class will skip strict\n *   dirty-checking for objects and arrays (always consider them to be\n *   \"dirty\").\n * - `notifyInstanceProp(instance, property, value)`: Called when\n *   an instance property changes.  Users may choose to call `notifyPath`\n *   on e.g. the owner to notify the change.\n * - `parentModel`: When `true`, events handled by declarative event listeners\n *   (`on-event=\"handler\"`) will be decorated with a `model` property pointing\n *   to the template instance that stamped it.  It will also be returned\n *   from `instance.parentModel` in cases where template instance nesting\n *   causes an inner model to shadow an outer model.\n *\n * All callbacks are called bound to the `owner`. Any context\n * needed for the callbacks (such as references to `instances` stamped)\n * should be stored on the `owner` such that they can be retrieved via\n * `this`.\n *\n * When `options.forwardHostProp` is declared as an option, any properties\n * referenced in the template will be automatically forwarded from the host of\n * the `<template>` to instances, with the exception of any properties listed in\n * the `options.instanceProps` object.  `instanceProps` are assumed to be\n * managed by the owner of the instances, either passed into the constructor\n * or set after the fact.  Note, any properties passed into the constructor will\n * always be set to the instance (regardless of whether they would normally\n * be forwarded from the host).\n *\n * Note that `templatize()` can be run only once for a given `<template>`.\n * Further calls will result in an error. Also, there is a special\n * behavior if the template was duplicated through a mechanism such as\n * `<dom-repeat>` or `<test-fixture>`. In this case, all calls to\n * `templatize()` return the same class for all duplicates of a template.\n * The class returned from `templatize()` is generated only once using\n * the `options` from the first call. This means that any `options`\n * provided to subsequent calls will be ignored. Therefore, it is very\n * important not to close over any variables inside the callbacks. Also,\n * arrow functions must be avoided because they bind the outer `this`.\n * Inside the callbacks, any contextual information can be accessed\n * through `this`, which points to the `owner`.\n *\n * @param {!HTMLTemplateElement} template Template to templatize\n * @param {Polymer_PropertyEffects=} owner Owner of the template instances;\n *   any optional callbacks will be bound to this owner.\n * @param {Object=} options Options dictionary (see summary for details)\n * @return {function(new:TemplateInstanceBase, Object=)} Generated class bound\n *   to the template provided\n * @suppress {invalidCasts}\n */\n\n\nexport function templatize(template, owner, options) {\n  // Under strictTemplatePolicy, the templatized element must be owned\n  // by a (trusted) Polymer element, indicated by existence of _methodHost;\n  // e.g. for dom-if & dom-repeat in main document, _methodHost is null\n  if (strictTemplatePolicy && !findMethodHost(template)) {\n    throw new Error('strictTemplatePolicy: template owner not trusted');\n  }\n\n  options =\n  /** @type {!TemplatizeOptions} */\n  options || {};\n\n  if (template.__templatizeOwner) {\n    throw new Error('A <template> can only be templatized once');\n  }\n\n  template.__templatizeOwner = owner;\n  const ctor = owner ? owner.constructor : TemplateInstanceBase;\n\n  let templateInfo = ctor._parseTemplate(template); // Get memoized base class for the prototypical template, which\n  // includes property effects for binding template & forwarding\n\n  /**\n   * @constructor\n   * @extends {TemplateInstanceBase}\n   */\n\n\n  let baseClass = templateInfo.templatizeInstanceClass;\n\n  if (!baseClass) {\n    baseClass = createTemplatizerClass(template, templateInfo, options);\n    templateInfo.templatizeInstanceClass = baseClass;\n  } // Host property forwarding must be installed onto template instance\n\n\n  addPropagateEffects(template, templateInfo, options); // Subclass base class and add reference for this specific template\n\n  /** @private */\n\n  let klass = class TemplateInstance extends baseClass {};\n  /** @override */\n\n  klass.prototype._methodHost = findMethodHost(template);\n  /** @override */\n\n  klass.prototype.__dataHost =\n  /** @type {!DataTemplate} */\n  template;\n  /** @override */\n\n  klass.prototype.__templatizeOwner =\n  /** @type {!Object} */\n  owner;\n  /** @override */\n\n  klass.prototype.__hostProps = templateInfo.hostProps;\n  klass =\n  /** @type {function(new:TemplateInstanceBase)} */\n  klass; //eslint-disable-line no-self-assign\n\n  return klass;\n}\n/**\n * Returns the template \"model\" associated with a given element, which\n * serves as the binding scope for the template instance the element is\n * contained in. A template model is an instance of\n * `TemplateInstanceBase`, and should be used to manipulate data\n * associated with this template instance.\n *\n * Example:\n *\n *   let model = modelForElement(el);\n *   if (model.index < 10) {\n *     model.set('item.checked', true);\n *   }\n *\n * @param {HTMLTemplateElement} template The model will be returned for\n *   elements stamped from this template\n * @param {Node=} node Node for which to return a template model.\n * @return {TemplateInstanceBase} Template instance representing the\n *   binding scope for the element\n */\n\nexport function modelForElement(template, node) {\n  let model;\n\n  while (node) {\n    // An element with a __templatizeInstance marks the top boundary\n    // of a scope; walk up until we find one, and then ensure that\n    // its __dataHost matches `this`, meaning this dom-repeat stamped it\n    if (model = node.__templatizeInstance) {\n      // Found an element stamped by another template; keep walking up\n      // from its __dataHost\n      if (model.__dataHost != template) {\n        node = model.__dataHost;\n      } else {\n        return model;\n      }\n    } else {\n      // Still in a template scope, keep going up until\n      // a __templatizeInstance is found\n      node = wrap(node).parentNode;\n    }\n  }\n\n  return null;\n}\nexport { TemplateInstanceBase };","map":null,"metadata":{},"sourceType":"module"}