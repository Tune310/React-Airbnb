{"ast":null,"code":"/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    `@apply` --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n'use strict';\n\nimport { forEachRule, processVariableAndFallback, rulesForStyle, toCssText, gatherStyleText } from './style-util.js';\nimport { MIXIN_MATCH, VAR_ASSIGN } from './common-regex.js';\nimport { detectMixin } from './common-utils.js';\nimport { StyleNode } from './css-parse.js'; // eslint-disable-line no-unused-vars\n\nconst APPLY_NAME_CLEAN = /;\\s*/m;\nconst INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nconst IMPORTANT = /\\s*!important/; // separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\n\nconst MIXIN_VAR_SEP = '_-_';\n/**\n * @typedef {!Object<string, string>}\n */\n\nlet PropertyEntry; // eslint-disable-line no-unused-vars\n\n/**\n * @typedef {!Object<string, boolean>}\n */\n\nlet DependantsEntry; // eslint-disable-line no-unused-vars\n\n/** @typedef {{\n *    properties: PropertyEntry,\n *    dependants: DependantsEntry\n * }}\n */\n\nlet MixinMapEntry; // eslint-disable-line no-unused-vars\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\n\nclass MixinMap {\n  constructor() {\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!PropertyEntry} props\n   */\n\n\n  set(name, props) {\n    name = name.trim();\n    this._map[name] = {\n      properties: props,\n      dependants: {}\n    };\n  }\n  /**\n   * @param {string} name\n   * @return {MixinMapEntry}\n   */\n\n\n  get(name) {\n    name = name.trim();\n    return this._map[name] || null;\n  }\n\n}\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\n\n\nlet invalidCallback = null;\n/** @unrestricted */\n\nclass ApplyShim {\n  constructor() {\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n\n\n  detectMixin(cssText) {\n    return detectMixin(cssText);\n  }\n  /**\n   * Gather styles into one style for easier processing\n   * @param {!HTMLTemplateElement} template\n   * @return {HTMLStyleElement}\n   */\n\n\n  gatherStyles(template) {\n    const styleText = gatherStyleText(template.content);\n\n    if (styleText) {\n      const style =\n      /** @type {!HTMLStyleElement} */\n      document.createElement('style');\n      style.textContent = styleText;\n      template.content.insertBefore(style, template.content.firstChild);\n      return style;\n    }\n\n    return null;\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n\n\n  transformTemplate(template, elementName) {\n    if (template._gatheredStyle === undefined) {\n      template._gatheredStyle = this.gatherStyles(template);\n    }\n    /** @type {HTMLStyleElement} */\n\n\n    const style = template._gatheredStyle;\n    return style ? this.transformStyle(style, elementName) : null;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n\n\n  transformStyle(style, elementName = '') {\n    let ast = rulesForStyle(style);\n    this.transformRules(ast, elementName);\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @return {StyleNode}\n   */\n\n\n  transformCustomStyle(style) {\n    let ast = rulesForStyle(style);\n    forEachRule(ast, rule => {\n      if (rule['selector'] === ':root') {\n        rule['selector'] = 'html';\n      }\n\n      this.transformRule(rule);\n    });\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {StyleNode} rules\n   * @param {string} elementName\n   */\n\n\n  transformRules(rules, elementName) {\n    this._currentElement = elementName;\n    forEachRule(rules, r => {\n      this.transformRule(r);\n    });\n    this._currentElement = null;\n  }\n  /**\n   * @param {!StyleNode} rule\n   */\n\n\n  transformRule(rule) {\n    rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule); // :root was only used for variable assignment in property shim,\n    // but generates invalid selectors with real properties.\n    // replace with `:host > *`, which serves the same effect\n\n    if (rule['selector'] === ':root') {\n      rule['selector'] = ':host > *';\n    }\n  }\n  /**\n   * @param {string} cssText\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n\n\n  transformCssText(cssText, rule) {\n    // produce variables\n    cssText = cssText.replace(VAR_ASSIGN, (matchText, propertyName, valueProperty, valueMixin) => this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule)); // consume mixins\n\n    return this._consumeCssProperties(cssText, rule);\n  }\n  /**\n   * @param {string} property\n   * @return {string}\n   */\n\n\n  _getInitialValueForProperty(property) {\n    if (!this._measureElement) {\n      this._measureElement =\n      /** @type {HTMLMetaElement} */\n      document.createElement('meta');\n\n      this._measureElement.setAttribute('apply-shim-measure', '');\n\n      this._measureElement.style.all = 'initial';\n      document.head.appendChild(this._measureElement);\n    }\n\n    return window.getComputedStyle(this._measureElement).getPropertyValue(property);\n  }\n  /**\n   * Walk over all rules before this rule to find fallbacks for mixins\n   *\n   * @param {!StyleNode} startRule\n   * @return {!Object}\n   */\n\n\n  _fallbacksFromPreviousRules(startRule) {\n    // find the \"top\" rule\n    let topRule = startRule;\n\n    while (topRule['parent']) {\n      topRule = topRule['parent'];\n    }\n\n    const fallbacks = {};\n    let seenStartRule = false;\n    forEachRule(topRule, r => {\n      // stop when we hit the input rule\n      seenStartRule = seenStartRule || r === startRule;\n\n      if (seenStartRule) {\n        return;\n      } // NOTE: Only matching selectors are \"safe\" for this fallback processing\n      // It would be prohibitive to run `matchesSelector()` on each selector,\n      // so we cheat and only check if the same selector string is used, which\n      // guarantees things like specificity matching\n\n\n      if (r['selector'] === startRule['selector']) {\n        Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));\n      }\n    });\n    return fallbacks;\n  }\n  /**\n   * replace mixin consumption with variable consumption\n   * @param {string} text\n   * @param {!StyleNode=} rule\n   * @return {string}\n   */\n\n\n  _consumeCssProperties(text, rule) {\n    /** @type {Array} */\n    let m = null; // loop over text until all mixins with defintions have been applied\n\n    while (m = MIXIN_MATCH.exec(text)) {\n      let matchText = m[0];\n      let mixinName = m[1];\n      let idx = m.index; // collect properties before apply to be \"defaults\" if mixin might override them\n      // match includes a \"prefix\", so find the start and end positions of @apply\n\n      let applyPos = idx + matchText.indexOf('@apply');\n      let afterApplyPos = idx + matchText.length; // find props defined before this @apply\n\n      let textBeforeApply = text.slice(0, applyPos);\n      let textAfterApply = text.slice(afterApplyPos);\n      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};\n      Object.assign(defaults, this._cssTextToMap(textBeforeApply));\n\n      let replacement = this._atApplyToCssProperties(mixinName, defaults); // use regex match position to replace mixin, keep linear processing time\n\n\n      text = \"\".concat(textBeforeApply).concat(replacement).concat(textAfterApply); // move regex search to _after_ replacement\n\n      MIXIN_MATCH.lastIndex = idx + replacement.length;\n    }\n\n    return text;\n  }\n  /**\n   * produce variable consumption at the site of mixin consumption\n   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n   * Example:\n   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n   *\n   * @param {string} mixinName\n   * @param {Object} fallbacks\n   * @return {string}\n   */\n\n\n  _atApplyToCssProperties(mixinName, fallbacks) {\n    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n    let vars = [];\n\n    let mixinEntry = this._map.get(mixinName); // if we depend on a mixin before it is created\n    // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n\n\n    if (!mixinEntry) {\n      this._map.set(mixinName, {});\n\n      mixinEntry = this._map.get(mixinName);\n    }\n\n    if (mixinEntry) {\n      if (this._currentElement) {\n        mixinEntry.dependants[this._currentElement] = true;\n      }\n\n      let p, parts, f;\n      const properties = mixinEntry.properties;\n\n      for (p in properties) {\n        f = fallbacks && fallbacks[p];\n        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n\n        if (f) {\n          parts.push(',', f.replace(IMPORTANT, ''));\n        }\n\n        parts.push(')');\n\n        if (IMPORTANT.test(properties[p])) {\n          parts.push(' !important');\n        }\n\n        vars.push(parts.join(''));\n      }\n    }\n\n    return vars.join('; ');\n  }\n  /**\n   * @param {string} property\n   * @param {string} value\n   * @return {string}\n   */\n\n\n  _replaceInitialOrInherit(property, value) {\n    let match = INITIAL_INHERIT.exec(value);\n\n    if (match) {\n      if (match[1]) {\n        // initial\n        // replace `initial` with the concrete initial value for this property\n        value = this._getInitialValueForProperty(property);\n      } else {\n        // inherit\n        // with this purposfully illegal value, the variable will be invalid at\n        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n        // and for inheriting values, will behave similarly\n        // we cannot support the same behavior for non inheriting values like 'border'\n        value = 'apply-shim-inherit';\n      }\n    }\n\n    return value;\n  }\n  /**\n   * \"parse\" a mixin definition into a map of properties and values\n   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n   * @param {string} text\n   * @param {boolean=} replaceInitialOrInherit\n   * @return {!Object<string, string>}\n   */\n\n\n  _cssTextToMap(text, replaceInitialOrInherit = false) {\n    let props = text.split(';');\n    let property, value;\n    let out = {};\n\n    for (let i = 0, p, sp; i < props.length; i++) {\n      p = props[i];\n\n      if (p) {\n        sp = p.split(':'); // ignore lines that aren't definitions like @media\n\n        if (sp.length > 1) {\n          property = sp[0].trim(); // some properties may have ':' in the value, like data urls\n\n          value = sp.slice(1).join(':');\n\n          if (replaceInitialOrInherit) {\n            value = this._replaceInitialOrInherit(property, value);\n          }\n\n          out[property] = value;\n        }\n      }\n    }\n\n    return out;\n  }\n  /**\n   * @param {MixinMapEntry} mixinEntry\n   */\n\n\n  _invalidateMixinEntry(mixinEntry) {\n    if (!invalidCallback) {\n      return;\n    }\n\n    for (let elementName in mixinEntry.dependants) {\n      if (elementName !== this._currentElement) {\n        invalidCallback(elementName);\n      }\n    }\n  }\n  /**\n   * @param {string} matchText\n   * @param {string} propertyName\n   * @param {?string} valueProperty\n   * @param {?string} valueMixin\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n\n\n  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin, rule) {\n    // handle case where property value is a mixin\n    if (valueProperty) {\n      // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n      processVariableAndFallback(valueProperty, (prefix, value) => {\n        if (value && this._map.get(value)) {\n          valueMixin = \"@apply \".concat(value, \";\");\n        }\n      });\n    }\n\n    if (!valueMixin) {\n      return matchText;\n    }\n\n    let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);\n\n    let prefix = matchText.slice(0, matchText.indexOf('--')); // `initial` and `inherit` as properties in a map should be replaced because\n    // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,\n    // and would set the variable value, rather than carry the keyword to the `var()` usage.\n\n    let mixinValues = this._cssTextToMap(mixinAsProperties, true);\n\n    let combinedProps = mixinValues;\n\n    let mixinEntry = this._map.get(propertyName);\n\n    let oldProps = mixinEntry && mixinEntry.properties;\n\n    if (oldProps) {\n      // NOTE: since we use mixin, the map of properties is updated here\n      // and this is what we want.\n      combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n    } else {\n      this._map.set(propertyName, combinedProps);\n    }\n\n    let out = [];\n    let p, v; // set variables defined by current mixin\n\n    let needToInvalidate = false;\n\n    for (p in combinedProps) {\n      v = mixinValues[p]; // if property not defined by current mixin, set initial\n\n      if (v === undefined) {\n        v = 'initial';\n      }\n\n      if (oldProps && !(p in oldProps)) {\n        needToInvalidate = true;\n      }\n\n      out.push(\"\".concat(propertyName).concat(MIXIN_VAR_SEP).concat(p, \": \").concat(v));\n    }\n\n    if (needToInvalidate) {\n      this._invalidateMixinEntry(mixinEntry);\n    }\n\n    if (mixinEntry) {\n      mixinEntry.properties = combinedProps;\n    } // because the mixinMap is global, the mixin might conflict with\n    // a different scope's simple variable definition:\n    // Example:\n    // some style somewhere:\n    // --mixin1:{ ... }\n    // --mixin2: var(--mixin1);\n    // some other element:\n    // --mixin1: 10px solid red;\n    // --foo: var(--mixin1);\n    // In this case, we leave the original variable definition in place.\n\n\n    if (valueProperty) {\n      prefix = \"\".concat(matchText, \";\").concat(prefix);\n    }\n\n    return \"\".concat(prefix).concat(out.join('; '), \";\");\n  }\n\n}\n/* exports */\n\n/* eslint-disable no-self-assign */\n\n\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\n/* eslint-enable no-self-assign */\n\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */\n  get() {\n    return invalidCallback;\n  },\n\n  /** @param {?function(string)} cb */\n  set(cb) {\n    invalidCallback = cb;\n  }\n\n});\nexport default ApplyShim;","map":null,"metadata":{},"sourceType":"module"}