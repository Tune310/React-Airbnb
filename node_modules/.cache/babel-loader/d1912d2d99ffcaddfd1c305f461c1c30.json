{"ast":null,"code":"/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nimport './boot.js';\nimport { wrap } from './wrap.js';\nconst ShadyDOM = window.ShadyDOM;\nconst ShadyCSS = window.ShadyCSS;\n/**\n * Return true if node scope is correct.\n *\n * @param {!Element} node Node to check scope\n * @param {!Node} scope Scope reference\n * @return {boolean} True if node is in scope\n */\n\nfunction sameScope(node, scope) {\n  return wrap(node).getRootNode() === scope;\n}\n/**\n * Ensure that elements in a ShadowDOM container are scoped correctly.\n * This function is only needed when ShadyDOM is used and unpatched DOM APIs are used in third party code.\n * This can happen in noPatch mode or when specialized APIs like ranges or tables are used to mutate DOM.\n *\n * @param  {!Element} container Container element to scope\n * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container\n * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.\n */\n\n\nexport function scopeSubtree(container, shouldObserve = false) {\n  // If using native ShadowDOM, abort\n  if (!ShadyDOM || !ShadyCSS) {\n    return null;\n  } // ShadyCSS handles DOM mutations when ShadyDOM does not handle scoping itself\n\n\n  if (!ShadyDOM['handlesDynamicScoping']) {\n    return null;\n  }\n\n  const ScopingShim = ShadyCSS['ScopingShim']; // if ScopingShim is not available, abort\n\n  if (!ScopingShim) {\n    return null;\n  } // capture correct scope for container\n\n\n  const containerScope = ScopingShim['scopeForNode'](container);\n  const root = wrap(container).getRootNode();\n\n  const scopify = node => {\n    if (!sameScope(node, root)) {\n      return;\n    } // NOTE: native qSA does not honor scoped DOM, but it is faster, and the same behavior as Polymer v1\n\n\n    const elements = Array.from(ShadyDOM['nativeMethods']['querySelectorAll'].call(node, '*'));\n    elements.push(node);\n\n    for (let i = 0; i < elements.length; i++) {\n      const el = elements[i];\n\n      if (!sameScope(el, root)) {\n        continue;\n      }\n\n      const currentScope = ScopingShim['currentScopeForNode'](el);\n\n      if (currentScope !== containerScope) {\n        if (currentScope !== '') {\n          ScopingShim['unscopeNode'](el, currentScope);\n        }\n\n        ScopingShim['scopeNode'](el, containerScope);\n      }\n    }\n  }; // scope everything in container\n\n\n  scopify(container);\n\n  if (shouldObserve) {\n    const mo = new MutationObserver(mxns => {\n      for (let i = 0; i < mxns.length; i++) {\n        const mxn = mxns[i];\n\n        for (let j = 0; j < mxn.addedNodes.length; j++) {\n          const addedNode = mxn.addedNodes[j];\n\n          if (addedNode.nodeType === Node.ELEMENT_NODE) {\n            scopify(addedNode);\n          }\n        }\n      }\n    });\n    mo.observe(container, {\n      childList: true,\n      subtree: true\n    });\n    return mo;\n  } else {\n    return null;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}