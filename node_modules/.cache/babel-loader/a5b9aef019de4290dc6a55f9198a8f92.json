{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/reidcrawford/Desktop/work/react-project/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        display: flex;\\n        flex-direction: column;\\n        height: 100%;\\n        width: 100%;\\n        outline: none;\\n        background: #fff;\\n      }\\n\\n      [part=\\\"overlay-header\\\"] {\\n        display: flex;\\n        flex-shrink: 0;\\n        flex-wrap: nowrap;\\n        align-items: center;\\n      }\\n\\n      :host(:not([fullscreen])) [part=\\\"overlay-header\\\"] {\\n        display: none;\\n      }\\n\\n      [part=\\\"label\\\"] {\\n        flex-grow: 1;\\n      }\\n\\n      [part=\\\"clear-button\\\"]:not([showclear]) {\\n        display: none;\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"] {\\n        display: flex;\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"][desktop] {\\n        display: none;\\n      }\\n\\n      :host(:not([years-visible])) [part=\\\"years-toggle-button\\\"]::before {\\n        transform: rotate(180deg);\\n      }\\n\\n      #scrollers {\\n        display: flex;\\n        height: 100%;\\n        width: 100%;\\n        position: relative;\\n        overflow: hidden;\\n      }\\n\\n      [part=\\\"months\\\"],\\n      [part=\\\"years\\\"] {\\n        height: 100%;\\n      }\\n\\n      [part=\\\"months\\\"] {\\n        --vaadin-infinite-scroller-item-height: 270px;\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        bottom: 0;\\n      }\\n\\n      #scrollers[desktop] [part=\\\"months\\\"] {\\n        right: 50px;\\n        transform: none !important;\\n      }\\n\\n      [part=\\\"years\\\"] {\\n        --vaadin-infinite-scroller-item-height: 80px;\\n        width: 50px;\\n        position: absolute;\\n        right: 0;\\n        transform: translateX(100%);\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        /* Center the year scroller position. */\\n        --vaadin-infinite-scroller-buffer-offset: 50%;\\n      }\\n\\n      #scrollers[desktop] [part=\\\"years\\\"] {\\n        position: absolute;\\n        transform: none !important;\\n      }\\n\\n      [part=\\\"years\\\"]::before {\\n        content: '';\\n        display: block;\\n        background: transparent;\\n        width: 0;\\n        height: 0;\\n        position: absolute;\\n        left: 0;\\n        top: 50%;\\n        transform: translateY(-50%);\\n        border-width: 6px;\\n        border-style: solid;\\n        border-color: transparent;\\n        border-left-color: #000;\\n      }\\n\\n      :host(.animate) [part=\\\"months\\\"],\\n      :host(.animate) [part=\\\"years\\\"] {\\n        transition: all 200ms;\\n      }\\n\\n      [part=\\\"toolbar\\\"] {\\n        display: flex;\\n        justify-content: space-between;\\n        z-index: 2;\\n        flex-shrink: 0;\\n      }\\n\\n      [part~=\\\"overlay-header\\\"]:not([desktop]) {\\n        padding-bottom: 40px;\\n      }\\n\\n      [part~=\\\"years-toggle-button\\\"] {\\n        position: absolute;\\n        top: auto;\\n        right: 8px;\\n        bottom: 0;\\n        z-index: 1;\\n        padding: 8px;\\n      }\\n\\n      #announcer {\\n        display: inline-block;\\n        position: fixed;\\n        clip: rect(0, 0, 0, 0);\\n        clip-path: inset(100%);\\n      }\\n    </style>\\n\\n    <div id=\\\"announcer\\\" role=\\\"alert\\\" aria-live=\\\"polite\\\">\\n      [[i18n.calendar]]\\n    </div>\\n\\n    <div part=\\\"overlay-header\\\" on-touchend=\\\"_preventDefault\\\" desktop$=\\\"[[_desktopMode]]\\\" aria-hidden=\\\"true\\\">\\n      <div part=\\\"label\\\">[[_formatDisplayed(selectedDate, i18n.formatDate, label)]]</div>\\n      <div part=\\\"clear-button\\\" on-tap=\\\"_clear\\\" showclear$=\\\"[[_showClear(selectedDate)]]\\\"></div>\\n      <div part=\\\"toggle-button\\\" on-tap=\\\"_cancel\\\"></div>\\n\\n      <div part=\\\"years-toggle-button\\\" desktop$=\\\"[[_desktopMode]]\\\" on-tap=\\\"_toggleYearScroller\\\" aria-hidden=\\\"true\\\">\\n        [[_yearAfterXMonths(_visibleMonthIndex)]]\\n      </div>\\n    </div>\\n\\n    <div id=\\\"scrollers\\\" desktop$=\\\"[[_desktopMode]]\\\" on-track=\\\"_track\\\">\\n      <vaadin-infinite-scroller id=\\\"monthScroller\\\" on-custom-scroll=\\\"_onMonthScroll\\\" on-touchstart=\\\"_onMonthScrollTouchStart\\\" buffer-size=\\\"3\\\" active=\\\"[[initialPosition]]\\\" part=\\\"months\\\">\\n        <template>\\n          <vaadin-month-calendar i18n=\\\"[[i18n]]\\\" month=\\\"[[_dateAfterXMonths(index)]]\\\" selected-date=\\\"{{selectedDate}}\\\" focused-date=\\\"[[focusedDate]]\\\" ignore-taps=\\\"[[_ignoreTaps]]\\\" show-week-numbers=\\\"[[showWeekNumbers]]\\\" min-date=\\\"[[minDate]]\\\" max-date=\\\"[[maxDate]]\\\" focused$=\\\"[[_focused]]\\\" part=\\\"month\\\" theme$=\\\"[[theme]]\\\">\\n          </vaadin-month-calendar>\\n        </template>\\n      </vaadin-infinite-scroller>\\n      <vaadin-infinite-scroller id=\\\"yearScroller\\\" on-tap=\\\"_onYearTap\\\" on-custom-scroll=\\\"_onYearScroll\\\" on-touchstart=\\\"_onYearScrollTouchStart\\\" buffer-size=\\\"12\\\" active=\\\"[[initialPosition]]\\\" part=\\\"years\\\">\\n        <template>\\n          <div part=\\\"year-number\\\" role=\\\"button\\\" current$=\\\"[[_isCurrentYear(index)]]\\\" selected$=\\\"[[_isSelectedYear(index, selectedDate)]]\\\">\\n            [[_yearAfterXYears(index)]]\\n          </div>\\n          <div part=\\\"year-separator\\\" aria-hidden=\\\"true\\\"></div>\\n        </template>\\n      </vaadin-infinite-scroller>\\n    </div>\\n\\n    <div on-touchend=\\\"_preventDefault\\\" role=\\\"toolbar\\\" part=\\\"toolbar\\\">\\n      <vaadin-button id=\\\"todayButton\\\" part=\\\"today-button\\\" disabled=\\\"[[!_isTodayAllowed(minDate, maxDate)]]\\\" on-tap=\\\"_onTodayTap\\\">\\n        [[i18n.today]]\\n      </vaadin-button>\\n      <vaadin-button id=\\\"cancelButton\\\" part=\\\"cancel-button\\\" on-tap=\\\"_cancel\\\">\\n        [[i18n.cancel]]\\n      </vaadin-button>\\n    </div>\\n\\n    <iron-media-query query=\\\"(min-width: 375px)\\\" query-matches=\\\"{{_desktopMode}}\\\"></iron-media-query>\\n\"], [\"\\n    <style>\\n      :host {\\n        display: flex;\\n        flex-direction: column;\\n        height: 100%;\\n        width: 100%;\\n        outline: none;\\n        background: #fff;\\n      }\\n\\n      [part=\\\"overlay-header\\\"] {\\n        display: flex;\\n        flex-shrink: 0;\\n        flex-wrap: nowrap;\\n        align-items: center;\\n      }\\n\\n      :host(:not([fullscreen])) [part=\\\"overlay-header\\\"] {\\n        display: none;\\n      }\\n\\n      [part=\\\"label\\\"] {\\n        flex-grow: 1;\\n      }\\n\\n      [part=\\\"clear-button\\\"]:not([showclear]) {\\n        display: none;\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"] {\\n        display: flex;\\n      }\\n\\n      [part=\\\"years-toggle-button\\\"][desktop] {\\n        display: none;\\n      }\\n\\n      :host(:not([years-visible])) [part=\\\"years-toggle-button\\\"]::before {\\n        transform: rotate(180deg);\\n      }\\n\\n      #scrollers {\\n        display: flex;\\n        height: 100%;\\n        width: 100%;\\n        position: relative;\\n        overflow: hidden;\\n      }\\n\\n      [part=\\\"months\\\"],\\n      [part=\\\"years\\\"] {\\n        height: 100%;\\n      }\\n\\n      [part=\\\"months\\\"] {\\n        --vaadin-infinite-scroller-item-height: 270px;\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        right: 0;\\n        bottom: 0;\\n      }\\n\\n      #scrollers[desktop] [part=\\\"months\\\"] {\\n        right: 50px;\\n        transform: none !important;\\n      }\\n\\n      [part=\\\"years\\\"] {\\n        --vaadin-infinite-scroller-item-height: 80px;\\n        width: 50px;\\n        position: absolute;\\n        right: 0;\\n        transform: translateX(100%);\\n        -webkit-tap-highlight-color: transparent;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        /* Center the year scroller position. */\\n        --vaadin-infinite-scroller-buffer-offset: 50%;\\n      }\\n\\n      #scrollers[desktop] [part=\\\"years\\\"] {\\n        position: absolute;\\n        transform: none !important;\\n      }\\n\\n      [part=\\\"years\\\"]::before {\\n        content: '';\\n        display: block;\\n        background: transparent;\\n        width: 0;\\n        height: 0;\\n        position: absolute;\\n        left: 0;\\n        top: 50%;\\n        transform: translateY(-50%);\\n        border-width: 6px;\\n        border-style: solid;\\n        border-color: transparent;\\n        border-left-color: #000;\\n      }\\n\\n      :host(.animate) [part=\\\"months\\\"],\\n      :host(.animate) [part=\\\"years\\\"] {\\n        transition: all 200ms;\\n      }\\n\\n      [part=\\\"toolbar\\\"] {\\n        display: flex;\\n        justify-content: space-between;\\n        z-index: 2;\\n        flex-shrink: 0;\\n      }\\n\\n      [part~=\\\"overlay-header\\\"]:not([desktop]) {\\n        padding-bottom: 40px;\\n      }\\n\\n      [part~=\\\"years-toggle-button\\\"] {\\n        position: absolute;\\n        top: auto;\\n        right: 8px;\\n        bottom: 0;\\n        z-index: 1;\\n        padding: 8px;\\n      }\\n\\n      #announcer {\\n        display: inline-block;\\n        position: fixed;\\n        clip: rect(0, 0, 0, 0);\\n        clip-path: inset(100%);\\n      }\\n    </style>\\n\\n    <div id=\\\"announcer\\\" role=\\\"alert\\\" aria-live=\\\"polite\\\">\\n      [[i18n.calendar]]\\n    </div>\\n\\n    <div part=\\\"overlay-header\\\" on-touchend=\\\"_preventDefault\\\" desktop\\\\$=\\\"[[_desktopMode]]\\\" aria-hidden=\\\"true\\\">\\n      <div part=\\\"label\\\">[[_formatDisplayed(selectedDate, i18n.formatDate, label)]]</div>\\n      <div part=\\\"clear-button\\\" on-tap=\\\"_clear\\\" showclear\\\\$=\\\"[[_showClear(selectedDate)]]\\\"></div>\\n      <div part=\\\"toggle-button\\\" on-tap=\\\"_cancel\\\"></div>\\n\\n      <div part=\\\"years-toggle-button\\\" desktop\\\\$=\\\"[[_desktopMode]]\\\" on-tap=\\\"_toggleYearScroller\\\" aria-hidden=\\\"true\\\">\\n        [[_yearAfterXMonths(_visibleMonthIndex)]]\\n      </div>\\n    </div>\\n\\n    <div id=\\\"scrollers\\\" desktop\\\\$=\\\"[[_desktopMode]]\\\" on-track=\\\"_track\\\">\\n      <vaadin-infinite-scroller id=\\\"monthScroller\\\" on-custom-scroll=\\\"_onMonthScroll\\\" on-touchstart=\\\"_onMonthScrollTouchStart\\\" buffer-size=\\\"3\\\" active=\\\"[[initialPosition]]\\\" part=\\\"months\\\">\\n        <template>\\n          <vaadin-month-calendar i18n=\\\"[[i18n]]\\\" month=\\\"[[_dateAfterXMonths(index)]]\\\" selected-date=\\\"{{selectedDate}}\\\" focused-date=\\\"[[focusedDate]]\\\" ignore-taps=\\\"[[_ignoreTaps]]\\\" show-week-numbers=\\\"[[showWeekNumbers]]\\\" min-date=\\\"[[minDate]]\\\" max-date=\\\"[[maxDate]]\\\" focused\\\\$=\\\"[[_focused]]\\\" part=\\\"month\\\" theme\\\\$=\\\"[[theme]]\\\">\\n          </vaadin-month-calendar>\\n        </template>\\n      </vaadin-infinite-scroller>\\n      <vaadin-infinite-scroller id=\\\"yearScroller\\\" on-tap=\\\"_onYearTap\\\" on-custom-scroll=\\\"_onYearScroll\\\" on-touchstart=\\\"_onYearScrollTouchStart\\\" buffer-size=\\\"12\\\" active=\\\"[[initialPosition]]\\\" part=\\\"years\\\">\\n        <template>\\n          <div part=\\\"year-number\\\" role=\\\"button\\\" current\\\\$=\\\"[[_isCurrentYear(index)]]\\\" selected\\\\$=\\\"[[_isSelectedYear(index, selectedDate)]]\\\">\\n            [[_yearAfterXYears(index)]]\\n          </div>\\n          <div part=\\\"year-separator\\\" aria-hidden=\\\"true\\\"></div>\\n        </template>\\n      </vaadin-infinite-scroller>\\n    </div>\\n\\n    <div on-touchend=\\\"_preventDefault\\\" role=\\\"toolbar\\\" part=\\\"toolbar\\\">\\n      <vaadin-button id=\\\"todayButton\\\" part=\\\"today-button\\\" disabled=\\\"[[!_isTodayAllowed(minDate, maxDate)]]\\\" on-tap=\\\"_onTodayTap\\\">\\n        [[i18n.today]]\\n      </vaadin-button>\\n      <vaadin-button id=\\\"cancelButton\\\" part=\\\"cancel-button\\\" on-tap=\\\"_cancel\\\">\\n        [[i18n.cancel]]\\n      </vaadin-button>\\n    </div>\\n\\n    <iron-media-query query=\\\"(min-width: 375px)\\\" query-matches=\\\"{{_desktopMode}}\\\"></iron-media-query>\\n\"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\n/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners.js';\nimport '@polymer/iron-media-query/iron-media-query.js';\nimport { IronA11yKeysBehavior } from '@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js';\nimport { IronA11yAnnouncer } from '@polymer/iron-a11y-announcer/iron-a11y-announcer.js';\nimport '@vaadin/vaadin-button/src/vaadin-button.js';\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ThemePropertyMixin } from '@vaadin/vaadin-themable-mixin/vaadin-theme-property-mixin.js';\nimport './vaadin-month-calendar.js';\nimport './vaadin-infinite-scroller.js';\nimport { DatePickerHelper } from './vaadin-date-picker-helper.js';\nimport './vaadin-date-picker-styles.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\nimport { addListener, setTouchAction } from '@polymer/polymer/lib/utils/gestures.js';\nimport { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';\nimport { timeOut } from '@polymer/polymer/lib/utils/async.js';\n/**\n * @memberof Vaadin\n * @private\n */\n\nclass DatePickerOverlayContentElement extends ThemableMixin(ThemePropertyMixin(GestureEventListeners(PolymerElement))) {\n  static get template() {\n    return html(_templateObject());\n  }\n\n  static get is() {\n    return 'vaadin-date-picker-overlay-content';\n  }\n\n  static get properties() {\n    return {\n      /**\n       * The value for this element.\n       */\n      selectedDate: {\n        type: Date,\n        notify: true\n      },\n\n      /**\n       * Date value which is focused using keyboard.\n       */\n      focusedDate: {\n        type: Date,\n        notify: true,\n        observer: '_focusedDateChanged'\n      },\n      _focusedMonthDate: Number,\n\n      /**\n       * Date which should be visible when there is no value selected.\n       */\n      initialPosition: {\n        type: Date,\n        observer: '_initialPositionChanged'\n      },\n      _originDate: {\n        value: new Date()\n      },\n      _visibleMonthIndex: Number,\n      _desktopMode: Boolean,\n      _translateX: {\n        observer: '_translateXChanged'\n      },\n      _yearScrollerWidth: {\n        value: 50\n      },\n      i18n: {\n        type: Object\n      },\n      showWeekNumbers: {\n        type: Boolean\n      },\n      _ignoreTaps: Boolean,\n      _notTapping: Boolean,\n\n      /**\n       * The earliest date that can be selected. All earlier dates will be disabled.\n       */\n      minDate: Date,\n\n      /**\n       * The latest date that can be selected. All later dates will be disabled.\n       */\n      maxDate: Date,\n      _focused: Boolean,\n\n      /**\n       * Input label\n       */\n      label: String\n    };\n  }\n\n  ready() {\n    super.ready();\n    this.setAttribute('tabindex', 0);\n    this.addEventListener('keydown', this._onKeydown.bind(this));\n    addListener(this, 'tap', this._stopPropagation);\n    this.addEventListener('focus', this._onOverlayFocus.bind(this));\n    this.addEventListener('blur', this._onOverlayBlur.bind(this));\n  }\n  /**\n   * Fired when the scroller reaches the target scrolling position.\n   * @event scroll-animation-finished\n   * @param {Number} detail.position new position\n   * @param {Number} detail.oldPosition old position\n   */\n\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    this._closeYearScroller();\n\n    this._toggleAnimateClass(true);\n\n    setTouchAction(this.$.scrollers, 'pan-y');\n    IronA11yAnnouncer.requestAvailability();\n  }\n\n  announceFocusedDate() {\n    var focusedDate = this._currentlyFocusedDate();\n\n    var announce = [];\n\n    if (DatePickerHelper._dateEquals(focusedDate, new Date())) {\n      announce.push(this.i18n.today);\n    }\n\n    announce = announce.concat([this.i18n.weekdays[focusedDate.getDay()], focusedDate.getDate(), this.i18n.monthNames[focusedDate.getMonth()], focusedDate.getFullYear()]);\n\n    if (this.showWeekNumbers && this.i18n.firstDayOfWeek === 1) {\n      announce.push(this.i18n.week);\n      announce.push(DatePickerHelper._getISOWeekNumber(focusedDate));\n    }\n\n    this.dispatchEvent(new CustomEvent('iron-announce', {\n      bubbles: true,\n      composed: true,\n      detail: {\n        text: announce.join(' ')\n      }\n    }));\n    return;\n  }\n  /**\n   * Focuses the cancel button\n   */\n\n\n  focusCancel() {\n    this.$.cancelButton.focus();\n  }\n  /**\n   * Scrolls the list to the given Date.\n   */\n\n\n  scrollToDate(date, animate) {\n    this._scrollToPosition(this._differenceInMonths(date, this._originDate), animate);\n  }\n\n  _focusedDateChanged(focusedDate) {\n    this.revealDate(focusedDate);\n  }\n\n  _isCurrentYear(yearsFromNow) {\n    return yearsFromNow === 0;\n  }\n\n  _isSelectedYear(yearsFromNow, selectedDate) {\n    if (selectedDate) {\n      return selectedDate.getFullYear() === this._originDate.getFullYear() + yearsFromNow;\n    }\n  }\n  /**\n   * Scrolls the month and year scrollers enough to reveal the given date.\n   */\n\n\n  revealDate(date) {\n    if (date) {\n      var diff = this._differenceInMonths(date, this._originDate);\n\n      var scrolledAboveViewport = this.$.monthScroller.position > diff;\n      var visibleItems = this.$.monthScroller.clientHeight / this.$.monthScroller.itemHeight;\n      var scrolledBelowViewport = this.$.monthScroller.position + visibleItems - 1 < diff;\n\n      if (scrolledAboveViewport) {\n        this._scrollToPosition(diff, true);\n      } else if (scrolledBelowViewport) {\n        this._scrollToPosition(diff - visibleItems + 1, true);\n      }\n    }\n  }\n\n  _onOverlayFocus() {\n    this._focused = true;\n  }\n\n  _onOverlayBlur() {\n    this._focused = false;\n  }\n\n  _initialPositionChanged(initialPosition) {\n    this.scrollToDate(initialPosition);\n  }\n\n  _repositionYearScroller() {\n    this._visibleMonthIndex = Math.floor(this.$.monthScroller.position);\n    this.$.yearScroller.position = (this.$.monthScroller.position + this._originDate.getMonth()) / 12;\n  }\n\n  _repositionMonthScroller() {\n    this.$.monthScroller.position = this.$.yearScroller.position * 12 - this._originDate.getMonth();\n    this._visibleMonthIndex = Math.floor(this.$.monthScroller.position);\n  }\n\n  _onMonthScroll() {\n    this._repositionYearScroller();\n\n    this._doIgnoreTaps();\n  }\n\n  _onYearScroll() {\n    this._repositionMonthScroller();\n\n    this._doIgnoreTaps();\n  }\n\n  _onYearScrollTouchStart() {\n    this._notTapping = false;\n    setTimeout(() => this._notTapping = true, 300);\n\n    this._repositionMonthScroller();\n  }\n\n  _onMonthScrollTouchStart() {\n    this._repositionYearScroller();\n  }\n\n  _doIgnoreTaps() {\n    this._ignoreTaps = true;\n    this._debouncer = Debouncer.debounce(this._debouncer, timeOut.after(300), () => this._ignoreTaps = false);\n  }\n\n  _formatDisplayed(date, formatDate, label) {\n    if (date) {\n      return formatDate(DatePickerHelper._extractDateParts(date));\n    } else {\n      return label;\n    }\n  }\n\n  _onTodayTap() {\n    var today = new Date();\n\n    if (Math.abs(this.$.monthScroller.position - this._differenceInMonths(today, this._originDate)) < 0.001) {\n      // Select today only if the month scroller is positioned approximately\n      // at the beginning of the current month\n      this.selectedDate = today;\n\n      this._close();\n    } else {\n      this._scrollToCurrentMonth();\n    }\n  }\n\n  _scrollToCurrentMonth() {\n    if (this.focusedDate) {\n      this.focusedDate = new Date();\n    }\n\n    this.scrollToDate(new Date(), true);\n  }\n\n  _showClear(selectedDate) {\n    return !!selectedDate;\n  }\n\n  _onYearTap(e) {\n    if (!this._ignoreTaps && !this._notTapping) {\n      var scrollDelta = e.detail.y - (this.$.yearScroller.getBoundingClientRect().top + this.$.yearScroller.clientHeight / 2);\n      var yearDelta = scrollDelta / this.$.yearScroller.itemHeight;\n\n      this._scrollToPosition(this.$.monthScroller.position + yearDelta * 12, true);\n    }\n  }\n\n  _scrollToPosition(targetPosition, animate) {\n    if (this._targetPosition !== undefined) {\n      this._targetPosition = targetPosition;\n      return;\n    }\n\n    if (!animate) {\n      this.$.monthScroller.position = targetPosition;\n      this._targetPosition = undefined;\n\n      this._repositionYearScroller();\n\n      return;\n    }\n\n    this._targetPosition = targetPosition; // http://gizma.com/easing/\n\n    var easingFunction = (t, b, c, d) => {\n      t /= d / 2;\n\n      if (t < 1) {\n        return c / 2 * t * t + b;\n      }\n\n      t--;\n      return -c / 2 * (t * (t - 2) - 1) + b;\n    };\n\n    var duration = animate ? 300 : 0;\n    var start = 0;\n    var initialPosition = this.$.monthScroller.position;\n\n    var smoothScroll = timestamp => {\n      start = start || timestamp;\n      var currentTime = timestamp - start;\n\n      if (currentTime < duration) {\n        var currentPos = easingFunction(currentTime, initialPosition, this._targetPosition - initialPosition, duration);\n        this.$.monthScroller.position = currentPos;\n        window.requestAnimationFrame(smoothScroll);\n      } else {\n        this.dispatchEvent(new CustomEvent('scroll-animation-finished', {\n          bubbles: true,\n          composed: true,\n          detail: {\n            position: this._targetPosition,\n            oldPosition: initialPosition\n          }\n        }));\n        this.$.monthScroller.position = this._targetPosition;\n        this._targetPosition = undefined;\n      }\n\n      setTimeout(this._repositionYearScroller.bind(this), 1);\n    }; // Start the animation.\n\n\n    window.requestAnimationFrame(smoothScroll);\n  }\n\n  _limit(value, range) {\n    return Math.min(range.max, Math.max(range.min, value));\n  }\n\n  _handleTrack(e) {\n    // Check if horizontal movement threshold (dx) not exceeded or\n    // scrolling fast vertically (ddy).\n    if (Math.abs(e.detail.dx) < 10 || Math.abs(e.detail.ddy) > 10) {\n      return;\n    } // If we're flinging quickly -> start animating already.\n\n\n    if (Math.abs(e.detail.ddx) > this._yearScrollerWidth / 3) {\n      this._toggleAnimateClass(true);\n    }\n\n    var newTranslateX = this._translateX + e.detail.ddx;\n    this._translateX = this._limit(newTranslateX, {\n      min: 0,\n      max: this._yearScrollerWidth\n    });\n  }\n\n  _track(e) {\n    if (this._desktopMode) {\n      // No need to track for swipe gestures on desktop.\n      return;\n    }\n\n    switch (e.detail.state) {\n      case 'start':\n        this._toggleAnimateClass(false);\n\n        break;\n\n      case 'track':\n        this._handleTrack(e);\n\n        break;\n\n      case 'end':\n        this._toggleAnimateClass(true);\n\n        if (this._translateX >= this._yearScrollerWidth / 2) {\n          this._closeYearScroller();\n        } else {\n          this._openYearScroller();\n        }\n\n        break;\n    }\n  }\n\n  _toggleAnimateClass(enable) {\n    if (enable) {\n      this.classList.add('animate');\n    } else {\n      this.classList.remove('animate');\n    }\n  }\n\n  _toggleYearScroller() {\n    this._isYearScrollerVisible() ? this._closeYearScroller() : this._openYearScroller();\n  }\n\n  _openYearScroller() {\n    this._translateX = 0;\n    this.setAttribute('years-visible', '');\n  }\n\n  _closeYearScroller() {\n    this.removeAttribute('years-visible');\n    this._translateX = this._yearScrollerWidth;\n  }\n\n  _isYearScrollerVisible() {\n    return this._translateX < this._yearScrollerWidth / 2;\n  }\n\n  _translateXChanged(x) {\n    if (!this._desktopMode) {\n      this.$.monthScroller.style.transform = 'translateX(' + (x - this._yearScrollerWidth) + 'px)';\n      this.$.yearScroller.style.transform = 'translateX(' + x + 'px)';\n    }\n  }\n\n  _yearAfterXYears(index) {\n    var result = new Date(this._originDate);\n    result.setFullYear(parseInt(index) + this._originDate.getFullYear());\n    return result.getFullYear();\n  }\n\n  _yearAfterXMonths(months) {\n    return this._dateAfterXMonths(months).getFullYear();\n  }\n\n  _dateAfterXMonths(months) {\n    var result = new Date(this._originDate);\n    result.setDate(1);\n    result.setMonth(parseInt(months) + this._originDate.getMonth());\n    return result;\n  }\n\n  _differenceInMonths(date1, date2) {\n    var months = (date1.getFullYear() - date2.getFullYear()) * 12;\n    return months - date2.getMonth() + date1.getMonth();\n  }\n\n  _differenceInYears(date1, date2) {\n    return this._differenceInMonths(date1, date2) / 12;\n  }\n\n  _clear() {\n    this.selectedDate = '';\n  }\n\n  _close() {\n    const overlayContent = this.getRootNode().host;\n    const overlay = overlayContent ? overlayContent.getRootNode().host : null;\n\n    if (overlay) {\n      overlay.opened = false;\n    }\n\n    this.dispatchEvent(new CustomEvent('close', {\n      bubbles: true,\n      composed: true\n    }));\n  }\n\n  _cancel() {\n    this.focusedDate = this.selectedDate;\n\n    this._close();\n  }\n\n  _preventDefault(e) {\n    e.preventDefault();\n  }\n  /**\n   * Keyboard Navigation\n   */\n\n\n  _eventKey(e) {\n    var keys = ['down', 'up', 'right', 'left', 'enter', 'space', 'home', 'end', 'pageup', 'pagedown', 'tab', 'esc'];\n\n    for (var i = 0; i < keys.length; i++) {\n      var k = keys[i];\n\n      if (IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k)) {\n        return k;\n      }\n    }\n  }\n\n  _onKeydown(e) {\n    var focus = this._currentlyFocusedDate(); // Cannot use (today/cancel).focused flag because vaadin-text-field removes it\n    // previously in the keydown event.\n\n\n    const isToday = e.composedPath().indexOf(this.$.todayButton) >= 0;\n    const isCancel = e.composedPath().indexOf(this.$.cancelButton) >= 0;\n    const isScroller = !isToday && !isCancel;\n\n    var eventKey = this._eventKey(e);\n\n    if (eventKey === 'tab') {\n      // We handle tabs here and don't want to bubble up.\n      e.stopPropagation();\n      const isFullscreen = this.hasAttribute('fullscreen');\n      const isShift = e.shiftKey;\n\n      if (isFullscreen) {\n        e.preventDefault();\n      } else if (isShift && isScroller || !isShift && isCancel) {\n        // Return focus back to the input field\n        e.preventDefault();\n        this.dispatchEvent(new CustomEvent('focus-input', {\n          bubbles: true,\n          composed: true\n        }));\n      } else if (isShift && isToday) {\n        // Browser returns focus back to the scrollable area. We need to set\n        // the focused flag, and move the scroll to focused date.\n        this._focused = true;\n        setTimeout(() => this.revealDate(this.focusedDate), 1);\n      } else {\n        // Browser moves the focus out of the scroller, hence focused flag must\n        // set to false.\n        this._focused = false;\n      }\n    } else if (eventKey) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      switch (eventKey) {\n        case 'down':\n          this._moveFocusByDays(7);\n\n          this.focus();\n          break;\n\n        case 'up':\n          this._moveFocusByDays(-7);\n\n          this.focus();\n          break;\n\n        case 'right':\n          if (isScroller) {\n            this._moveFocusByDays(1);\n          }\n\n          break;\n\n        case 'left':\n          if (isScroller) {\n            this._moveFocusByDays(-1);\n          }\n\n          break;\n\n        case 'enter':\n          if (isScroller || isCancel) {\n            this._close();\n          } else if (isToday) {\n            this._onTodayTap();\n          }\n\n          break;\n\n        case 'space':\n          if (isCancel) {\n            this._close();\n          } else if (isToday) {\n            this._onTodayTap();\n          } else {\n            var focusedDate = this.focusedDate;\n\n            if (DatePickerHelper._dateEquals(focusedDate, this.selectedDate)) {\n              this.selectedDate = '';\n              this.focusedDate = focusedDate;\n            } else {\n              this.selectedDate = focusedDate;\n            }\n          }\n\n          break;\n\n        case 'home':\n          this._moveFocusInsideMonth(focus, 'minDate');\n\n          break;\n\n        case 'end':\n          this._moveFocusInsideMonth(focus, 'maxDate');\n\n          break;\n\n        case 'pagedown':\n          this._moveFocusByMonths(e.shiftKey ? 12 : 1);\n\n          break;\n\n        case 'pageup':\n          this._moveFocusByMonths(e.shiftKey ? -12 : -1);\n\n          break;\n\n        case 'esc':\n          this._cancel();\n\n          break;\n      }\n    }\n  }\n\n  _currentlyFocusedDate() {\n    return this.focusedDate || this.selectedDate || this.initialPosition || new Date();\n  }\n\n  _focusDate(dateToFocus) {\n    this.focusedDate = dateToFocus;\n    this._focusedMonthDate = dateToFocus.getDate();\n  }\n\n  _focusClosestDate(focus) {\n    this._focusDate(DatePickerHelper._getClosestDate(focus, [this.minDate, this.maxDate]));\n  }\n\n  _moveFocusByDays(days) {\n    var focus = this._currentlyFocusedDate();\n\n    var dateToFocus = new Date(0, 0);\n    dateToFocus.setFullYear(focus.getFullYear());\n    dateToFocus.setMonth(focus.getMonth());\n    dateToFocus.setDate(focus.getDate() + days);\n\n    if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {\n      this._focusDate(dateToFocus);\n    } else {\n      if (this._dateAllowed(focus, this.minDate, this.maxDate)) {\n        // Move to min or max date\n        if (days > 0) {\n          // down or right\n          this._focusDate(this.maxDate);\n        } else {\n          // up or left\n          this._focusDate(this.minDate);\n        }\n      } else {\n        // Move to closest allowed date\n        this._focusClosestDate(focus);\n      }\n    }\n  }\n\n  _moveFocusByMonths(months) {\n    var focus = this._currentlyFocusedDate();\n\n    var dateToFocus = new Date(0, 0);\n    dateToFocus.setFullYear(focus.getFullYear());\n    dateToFocus.setMonth(focus.getMonth() + months);\n    var targetMonth = dateToFocus.getMonth();\n    dateToFocus.setDate(this._focusedMonthDate || (this._focusedMonthDate = focus.getDate()));\n\n    if (dateToFocus.getMonth() !== targetMonth) {\n      dateToFocus.setDate(0);\n    }\n\n    if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {\n      this.focusedDate = dateToFocus;\n    } else {\n      if (this._dateAllowed(focus, this.minDate, this.maxDate)) {\n        // Move to min or max date\n        if (months > 0) {\n          // pagedown\n          this._focusDate(this.maxDate);\n        } else {\n          // pageup\n          this._focusDate(this.minDate);\n        }\n      } else {\n        // Move to closest allowed date\n        this._focusClosestDate(focus);\n      }\n    }\n  }\n\n  _moveFocusInsideMonth(focusedDate, property) {\n    var dateToFocus = new Date(0, 0);\n    dateToFocus.setFullYear(focusedDate.getFullYear());\n\n    if (property === 'minDate') {\n      dateToFocus.setMonth(focusedDate.getMonth());\n      dateToFocus.setDate(1);\n    } else {\n      dateToFocus.setMonth(focusedDate.getMonth() + 1);\n      dateToFocus.setDate(0);\n    }\n\n    if (this._dateAllowed(dateToFocus, this.minDate, this.maxDate)) {\n      this._focusDate(dateToFocus);\n    } else {\n      if (this._dateAllowed(focusedDate, this.minDate, this.maxDate)) {\n        // Move to minDate or maxDate\n        this._focusDate(this[property]);\n      } else {\n        // Move to closest allowed date\n        this._focusClosestDate(focusedDate);\n      }\n    }\n  }\n\n  _dateAllowed(date, min, max) {\n    return (!min || date >= min) && (!max || date <= max);\n  }\n\n  _isTodayAllowed(min, max) {\n    var today = new Date();\n    var todayMidnight = new Date(0, 0);\n    todayMidnight.setFullYear(today.getFullYear());\n    todayMidnight.setMonth(today.getMonth());\n    todayMidnight.setDate(today.getDate());\n    return this._dateAllowed(todayMidnight, min, max);\n  }\n\n  _stopPropagation(e) {\n    e.stopPropagation();\n  }\n\n}\n\ncustomElements.define(DatePickerOverlayContentElement.is, DatePickerOverlayContentElement);","map":null,"metadata":{},"sourceType":"module"}